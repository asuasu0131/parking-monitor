<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>駐車場ナビ 完全修正版</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="style.css">
<style>
body { font-family:sans-serif; }

#parking-lot-container{
  width:90vw;
  max-width:900px;
  height:70vh;
  margin:auto;
  background:#bbb;
  position:relative;
  overflow:hidden;
}

#parking-lot{ position:absolute; inset:0; }

#path-canvas{
  position:absolute;
  inset:0;
  z-index:5;
  pointer-events:none;
}

.rod{
  position:absolute;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:bold;
  color:white;
  border-radius:6px;
}
.empty{ background:#4caf50; }
.full{ background:#f44336; }

#user-marker{
  width:12px;
  height:12px;
  background:black;
  border-radius:50%;
  position:absolute;
  z-index:10;
}
</style>
</head>
<body>

<h2 style="text-align:center">駐車場ナビ（完全修正版）</h2>

<div id="parking-lot-container">
  <div id="parking-lot"></div>
  <canvas id="path-canvas"></canvas>
  <div id="user-marker"></div>
</div>

<script>
/* ===== ここから virtual.js の内容 ===== */
const container = document.getElementById("parking-lot-container");
const lot = document.getElementById("parking-lot");
const canvas = document.getElementById("path-canvas");
const ctx = canvas.getContext("2d");
const userMarker = document.getElementById("user-marker");

const rowCount = 9;
const colCount = 6;
const colW = 70;
const rowH = 50;
const padRows = 1;
let user = { x:0, y:0 };

// ===== ロッド =====
const rods=[];
for(let r=0;r<rowCount;r++){
  [["A",0],["B",2],["C",3],["D",5]].forEach(([k,c])=>{
    rods.push({id:`${k}${r+1}`,row:r,col:c,status:0});
  });
}
rods.forEach(r=>{
  const d=document.createElement("div");
  d.className="rod empty";
  d.style.width=colW+"px";
  d.style.height=rowH+"px";
  d.textContent=r.id;
  d.onclick=()=>{
    r.status^=1;
    d.className="rod "+(r.status?"full":"empty");
    needsUpdate = true;
  };
  lot.appendChild(d);
  r.el=d;
});

// ===== ノード =====
const nodeMap=new Map();
function key(r,c){return `${r},${c}`;}
function getNode(r,c){
  const k=key(r,c);
  if(!nodeMap.has(k)){
    nodeMap.set(k,{row:r,col:c,x:0,y:0,neighbors:[],rod:null});
  }
  return nodeMap.get(k);
}

// 通路ノード
for(let r=0;r<rowCount+padRows*2;r++){
  for(let c=0;c<colCount;c++){
    if(![0,2,3,5].includes(c)) getNode(r,c);
  }
}

// ロッド前ノード
rods.forEach(r=>{
  const nr=r.row+padRows;
  const nc=(r.col<=2)?1:4;
  const n=getNode(nr,nc);
  n.rod=r;
  r.front=n;
});

// 通路入り口ノード
const entryNodes=[getNode(0,1), getNode(0,4)];

// 隣接
nodeMap.forEach(n=>{
  [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{
    const nb=nodeMap.get(key(n.row+dr,n.col+dc));
    if(nb) n.neighbors.push(nb);
  });
});
const nodes=[...nodeMap.values()];

// ===== 座標 =====
function resize(){
  canvas.width=container.clientWidth;
  canvas.height=container.clientHeight;
  const offX=(canvas.width-colCount*colW)/2;
  const offY=(canvas.height-(rowCount+padRows*2)*rowH)/2;

  nodes.forEach(n=>{
    n.x=offX+n.col*colW+colW/2;
    n.y=offY+n.row*rowH+rowH/2;
  });

  rods.forEach(r=>{
    r.cx=offX+r.col*colW+colW/2;
    r.cy=offY+(r.row+padRows)*rowH+rowH/2;
    r.el.style.left=r.cx-colW/2+"px";
    r.el.style.top=r.cy-rowH/2+"px";
  });

  if(user.x===0 && user.y===0){
    user.x=canvas.width/2;
    user.y=canvas.height-rowH;
  }

  needsUpdate = true;
}
resize();
window.addEventListener("resize",resize);

// ===== A* =====
function h(a,b){return Math.abs(a.row-b.row)+Math.abs(a.col-b.col);}
function astar(s,g){
  if(!s || !g) return [];
  const open=[s],came=new Map(),gScore=new Map([[s,0]]);
  let safety=0;
  while(open.length && safety<1000){
    safety++;
    open.sort((a,b)=>(gScore.get(a)+h(a,g))-(gScore.get(b)+h(b,g)));
    const cur=open.shift();
    if(cur===g){
      const p=[]; let c=cur;
      while(c){p.unshift(c);c=came.get(c);}
      return p;
    }
    cur.neighbors.forEach(n=>{
      const t=gScore.get(cur)+1;
      if(t<(gScore.get(n)||1e9)){
        came.set(n,cur);
        gScore.set(n,t);
        if(!open.includes(n)) open.push(n);
      }
    });
  }
  return [];
}

// ===== 経路 =====
function nearestNode(){
  return nodes.reduce((a,b)=>
    Math.hypot(b.x-user.x,b.y-user.y)<
    Math.hypot(a.x-user.x,a.y-user.y)?b:a);
}
function goalNode(){
  const e=rods.filter(r=>!r.status);
  if(!e.length) return null;
  return e.reduce((a,b)=>
    Math.hypot(b.cx-user.x,b.cy-user.y)<
    Math.hypot(a.cx-user.x,a.cy-user.y)?b:a).front;
}

// ===== 描画 =====
function draw(p){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(!p || !p.length) return;
  ctx.strokeStyle="blue";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.moveTo(user.x,user.y);
  p.forEach(n=>ctx.lineTo(n.x,n.y));
  ctx.stroke();
}

// ===== ユーザー操作 =====
const moveStep=5;
let needsUpdate = true;

window.addEventListener("keydown",e=>{
  if(e.key==="ArrowUp"){ user.y-=moveStep; needsUpdate=true; }
  if(e.key==="ArrowDown"){ user.y+=moveStep; needsUpdate=true; }
  if(e.key==="ArrowLeft"){ user.x-=moveStep; needsUpdate=true; }
  if(e.key==="ArrowRight"){ user.x+=moveStep; needsUpdate=true; }
});

// ===== メインループ =====
(function loop(){
  if(needsUpdate){
    const s=nearestNode();
    const g=goalNode();
    if(g){
      const entry = entryNodes.reduce((a,b)=>
        Math.hypot(b.x-user.x,b.y-user.y)<
        Math.hypot(a.x-user.x,a.y-user.y)?b:a);
      const path1=astar(s,entry);
      const path2=astar(entry,g);
      draw([...path1,...path2]);
    } else {
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    needsUpdate = false;
  }
  userMarker.style.left=(user.x-6)+"px";
  userMarker.style.top=(user.y-6)+"px";
  requestAnimationFrame(loop);
})();
/* ===== ここまで ===== */
</script>

</body>
</html>